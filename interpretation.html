<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="description" content="Now that we have representations, what do we do with them?">

<title>Basics of Interpretation – vsa-compilation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js" type="module"></script>
<script src="site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-e16dd29f819a46fcdaa82e3575888691.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
<meta property="og:title" content="Basics of Interpretation – vsa-compilation">
<meta property="og:description" content="Now that we have representations, what do we do with them?">
<meta property="og:image" content="https://hanleyc01.github.io/vsa-compilation/tree.png">
<meta property="og:site_name" content="vsa-compilation">
<meta property="og:image:height" content="1184">
<meta property="og:image:width" content="1002">
<meta name="twitter:title" content="Basics of Interpretation – vsa-compilation">
<meta name="twitter:description" content="Now that we have representations, what do we do with them?">
<meta name="twitter:image" content="https://hanleyc01.github.io/vsa-compilation/tree.png">
<meta name="twitter:image-height" content="1184">
<meta name="twitter:image-width" content="1002">
<meta name="twitter:card" content="summary_large_image">
</head>

<body class="nav-sidebar floating nav-fixed quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">vsa-compilation</span>
    </a>
  </div>
        <div class="quarto-navbar-tools tools-end">
</div>
          <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./interpretation.html">Basics of Interpretation</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Introduction to Compilation with VSAs.</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./vsas.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">An Introduction to VSAs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./syntax.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Basics of representing syntax with VSAs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./interpretation.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Basics of Interpretation</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./lisp.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Encoding LISP in VSAs</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./forth.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Encoding FORTH in VSAs</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#overview-of-this-section" id="toc-overview-of-this-section" class="nav-link active" data-scroll-target="#overview-of-this-section">Overview of this Section</a></li>
  <li><a href="#associative-memories-and-pointers" id="toc-associative-memories-and-pointers" class="nav-link" data-scroll-target="#associative-memories-and-pointers">Associative Memories and Pointers</a>
  <ul class="collapse">
  <li><a href="#creating-a-cleanup-and-associative-memory" id="toc-creating-a-cleanup-and-associative-memory" class="nav-link" data-scroll-target="#creating-a-cleanup-and-associative-memory">Creating a Cleanup and Associative Memory</a></li>
  <li><a href="#applying-memories-to-encoding-and-decoding" id="toc-applying-memories-to-encoding-and-decoding" class="nav-link" data-scroll-target="#applying-memories-to-encoding-and-decoding">Applying memories to encoding and decoding</a></li>
  </ul></li>
  <li><a href="#alternative-representations-of-syntax" id="toc-alternative-representations-of-syntax" class="nav-link" data-scroll-target="#alternative-representations-of-syntax">Alternative Representations of Syntax</a>
  <ul class="collapse">
  <li><a href="#trees" id="toc-trees" class="nav-link" data-scroll-target="#trees">Trees</a></li>
  <li><a href="#lists" id="toc-lists" class="nav-link" data-scroll-target="#lists">Lists</a></li>
  </ul></li>
  <li><a href="#its-just-semantics" id="toc-its-just-semantics" class="nav-link" data-scroll-target="#its-just-semantics">It’s just semantics</a>
  <ul class="collapse">
  <li><a href="#designing-a-denotation" id="toc-designing-a-denotation" class="nav-link" data-scroll-target="#designing-a-denotation">Designing a denotation</a>
  <ul class="collapse">
  <li><a href="#a-denotation-for-mathcall_textfruit" id="toc-a-denotation-for-mathcall_textfruit" class="nav-link" data-scroll-target="#a-denotation-for-mathcall_textfruit">A denotation for <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span></a></li>
  </ul></li>
  <li><a href="#real-world-example" id="toc-real-world-example" class="nav-link" data-scroll-target="#real-world-example">Real-world example</a></li>
  </ul></li>
  <li><a href="#the-let-programming-language" id="toc-the-let-programming-language" class="nav-link" data-scroll-target="#the-let-programming-language">The LET Programming Language</a>
  <ul class="collapse">
  <li><a href="#the-semantics-for-mathcall_textlet" id="toc-the-semantics-for-mathcall_textlet" class="nav-link" data-scroll-target="#the-semantics-for-mathcall_textlet">The Semantics for <span class="math inline">\(\mathcal{L}_\text{let}\)</span></a></li>
  </ul></li>
  </ul>
<div class="toc-actions"><ul><li><a href="https://github.com/hanleyc01/vsa-compilation/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div><div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="interpretation.html.md"><i class="bi bi-file-code"></i>CommonMark</a></li></ul></div></nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Basics of Interpretation</h1>
</div>

<div>
  <div class="description">
    Now that we have representations, what do we do with them?
  </div>
</div>


<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<!-- WARNING: THIS FILE WAS AUTOGENERATED! DO NOT EDIT! -->
<section id="overview-of-this-section" class="level1">
<h1>Overview of this Section</h1>
<p>In this section we will broadly discuss how to represent interpretation in programming languages encoded high-dimensional vector space. In order to work up to this point, first we will discuss some problems with the memory capacity of VSAs: specifically, how we can get around information-loss as a result of VSA operations by using <em>associative memories</em>. Then, we will discuss other ways of representing syntax. Finally, we will talk about what is interpretation and program execution by thinking about a way of talking about how programs work: <a href="https://en.wikipedia.org/wiki/Denotational_semantics"><em>denotational semantics</em></a>. We will then apply this knowledge to another toy language, the LET language.</p>
</section>
<section id="associative-memories-and-pointers" class="level1">
<h1>Associative Memories and Pointers</h1>
<p>Recall our previous example of encoding the simple language <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span> in high-dimensional vectors. We found that we can both <em>encode</em> the abstract syntax into the high-dimensional vectors using VSA operations, as well as decode them.</p>
<p>But, as we will show, the decoding breaks down with even <span class="math inline">\(1\)</span>-deep nesting of syntax. We say that a composite expression <span class="math inline">\(\phi\)</span> is <span class="math inline">\(n\)</span>-deep by counting the longest length of composite sub-expressions that it contains. Atomic expressions are <span class="math inline">\(0\)</span>-deep. Ideally, for languages which are compositional, we would like for any syntactic expression to be able to be arbitrarily deep. So, we could have a tuple of tuples of tuples of tuples, etc. But, because of the information loss inherent in VSA operations, we quickly find that without some indirection, this becomes untenable.</p>
<div id="3c14c803" class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dataclasses <span class="im">import</span> dataclass</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> abc <span class="im">import</span> ABCMeta</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> L(metaclass<span class="op">=</span>ABCMeta):</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Abstract base class of our language L."""</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Atomic(L):</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Abstract base class of atomic elements in the language."""</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>    name: <span class="bu">str</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Tuple(L):</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Tuples in L."""</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>    lhs: L</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>    rhs: L</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Disjunction(L):</span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Disjunctions in L."""</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>    lhs: L</span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>    rhs: L</span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">1_000</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> [<span class="st">"atomic"</span>, <span class="st">"tuple"</span>, <span class="st">"disjunction"</span>]</span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> [<span class="st">"tag"</span>, <span class="st">"name"</span>, <span class="st">"lhs"</span>, <span class="st">"rhs"</span>]</span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="st">"strawberry"</span>, <span class="st">"banana"</span>, <span class="st">"apple"</span>]</span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a>codebook <span class="op">=</span> Codebook(T <span class="op">+</span> R <span class="op">+</span> A, dim<span class="op">=</span>dim)</span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> encode(expr: L, codebook: Codebook <span class="op">=</span> codebook) <span class="op">-&gt;</span> HRR:</span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Encode a formula in the language $</span><span class="er">\</span><span class="co">mathcal{L}_{</span><span class="ch">\t</span><span class="co">ext{fruit}}$."""</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">isinstance</span>(expr, L):</span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="st">"Expected a subclass of L"</span>, expr)</span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(expr, Atomic):</span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a>        name <span class="op">=</span> expr.name</span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> role_filler_pair(</span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a>            {</span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a>                <span class="st">"tag"</span>: <span class="st">"atomic"</span>,</span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a>                <span class="st">"name"</span>: codebook[name],</span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a>            codebook<span class="op">=</span>codebook,</span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, Tuple):</span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a>        lhs <span class="op">=</span> expr.lhs</span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>        rhs <span class="op">=</span> expr.rhs</span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> role_filler_pair(</span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>            {</span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a>                <span class="st">"tag"</span>: <span class="st">"tuple"</span>,</span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>                <span class="st">"lhs"</span>: encode(lhs, codebook<span class="op">=</span>codebook),</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a>                <span class="st">"rhs"</span>: encode(rhs, codebook<span class="op">=</span>codebook),</span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a>            codebook<span class="op">=</span>codebook,</span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, Disjunction):</span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a>        lhs <span class="op">=</span> expr.lhs</span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a>        rhs <span class="op">=</span> expr.rhs</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> role_filler_pair(</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a>            {</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a>                <span class="st">"tag"</span>: <span class="st">"disjunction"</span>,</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a>                <span class="st">"lhs"</span>: encode(lhs, codebook<span class="op">=</span>codebook),</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a>                <span class="st">"rhs"</span>: encode(rhs, codebook<span class="op">=</span>codebook),</span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a>            codebook<span class="op">=</span>codebook,</span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> decode(enc: HRR, codebook<span class="op">=</span>codebook, theta: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span>) <span class="op">-&gt;</span> L:</span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Decode a representation back to ``L``."""</span></span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a>    tag <span class="op">=</span> enc.bind(codebook[<span class="st">"tag"</span>].inverse())</span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>    t_atom <span class="op">=</span> codebook[<span class="st">"atomic"</span>]</span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a>    t_tuple <span class="op">=</span> codebook[<span class="st">"tuple"</span>]</span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>    t_disj <span class="op">=</span> codebook[<span class="st">"disjunction"</span>]</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> tag.cosine_similarity(t_atom) <span class="op">&gt;</span> theta:</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a>        name <span class="op">=</span> enc.bind(codebook[<span class="st">"name"</span>].inverse())</span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recall the name from the codebook</span></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a>        keys, values <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>codebook.items())</span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>        V <span class="op">=</span> np.array(values)</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>        sims <span class="op">=</span> V <span class="op">@</span> name</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>        argmax <span class="op">=</span> np.argmax(sims)</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Atomic(keys[argmax])</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Trick here is that both of the other representations have</span></span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a>        <span class="co"># an `lhs` and a `rhs`.</span></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a>        lhs <span class="op">=</span> enc.bind(codebook[<span class="st">"lhs"</span>].inverse())</span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>        rhs <span class="op">=</span> enc.bind(codebook[<span class="st">"rhs"</span>].inverse())</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>        dec_lhs <span class="op">=</span> decode(lhs, codebook<span class="op">=</span>codebook, theta<span class="op">=</span>theta)</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>        dec_rhs <span class="op">=</span> decode(rhs, codebook<span class="op">=</span>codebook, theta<span class="op">=</span>theta)</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> tag.cosine_similarity(t_tuple) <span class="op">&gt;</span> theta:</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Tuple(dec_lhs, dec_rhs)</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> tag.cosine_similarity(t_disj) <span class="op">&gt;</span> theta:</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Disjunction(dec_lhs, dec_rhs)</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="st">"Unkown value!"</span>)</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing tuples:</span></span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>straw <span class="op">=</span> Atomic(<span class="st">"strawberry"</span>)</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>apple <span class="op">=</span> Atomic(<span class="st">"apple"</span>)</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>enc_apple <span class="op">=</span> encode(apple)</span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>tupl <span class="op">=</span> Tuple(straw, apple)</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original form: </span><span class="sc">{</span>tupl<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>enc_tupl <span class="op">=</span> encode(tupl)</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>dec_tupl <span class="op">=</span> decode(enc_tupl)</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Decoded form: </span><span class="sc">{</span>dec_tupl<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>()</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing one-deep disjunctions</span></span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a><span class="co"># disj = Disjunction(tupl, apple)           # Uncommenting this throws errors</span></span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"Original form: {disj}")</span></span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a><span class="co"># enc_disj = encode(disj)</span></span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a><span class="co"># dec_disj = decode(enc_disj)</span></span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="co"># print(f"Decoded form: {dec_disj}")</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Original form: Tuple(lhs=Atomic(name='strawberry'), rhs=Atomic(name='apple'))
Decoded form: Tuple(lhs=Atomic(name='strawberry'), rhs=Atomic(name='apple'))
</code></pre>
</div>
</div>
<p>Even with a simple <span class="math inline">\(1\)</span>-deep expression, our decoding function is unable to parse out that the left-hand side of <code>enc_disj</code> is a tuple. The key problem here is that we can think of VSA operations as a kind of information compression. Specifically, binding leads to a loss of information, and this loss depends on the kind of binding operation that we use <a href="https://psycnet.apa.org/doiLanding?doi=10.1037%2Fa0030301">(Kelly <em>et al.</em>, 2013)</a>.</p>
<p>To solve this problem, we need to be able to add (1) indirection into the representation, allowing for the information to be preserved even under many binding operations, (2) a way to “clean-up” or “clarify” noisy representations, gravitating them back to their original form.</p>
<p>To do this, we use <em>associative memories</em>, which are distributed, content-addressable memories that recontsruct queries based on stored information in their weights. Associative memories are well-suited for our high-dimensional representation as they are continuous and differentiable as well.</p>
<section id="creating-a-cleanup-and-associative-memory" class="level2">
<h2 class="anchored" data-anchor-id="creating-a-cleanup-and-associative-memory">Creating a Cleanup and Associative Memory</h2>
<p>For more intuition here, we will be creating both a cleanup and associative memory. A cleanup memory <span class="math inline">\(\mathcal{C}\)</span> is an auto-associative memory which stores <span class="math inline">\(N\)</span> high-dimensional vectors of dimension <span class="math inline">\(D\)</span>. If <span class="math inline">\(x\)</span> is a high-dimensional vector stored in the weights of <span class="math inline">\(\mathcal C\)</span>, then <span class="math inline">\(\mathcal C(x) \approx x\)</span>. If <span class="math inline">\(x'\)</span> is a degraded form of a stored memory item in <span class="math inline">\(C\)</span>, then <span class="math inline">\(\mathcal C(x') \approx x\)</span>, where <span class="math inline">\(x\)</span> is the original form of the memory item. Cleanup memories are useful for recovering the original form of bound variables.</p>
<p>The next associative memory that we will be using is a hetero-associative memory <span class="math inline">\(\mathcal D\)</span> that stores <span class="math inline">\(N \times N\)</span> items, or <span class="math inline">\(N\)</span> addresses of high-dimensional vectors and <span class="math inline">\(N\)</span> patterns of high-dimensional vectors. We write to memory both an address vector and a pattern vector. If <span class="math inline">\(x\)</span> is a high-dimensional vector stored in the addresses in <span class="math inline">\(\mathcal D\)</span>, and <span class="math inline">\(y\)</span> is the a high-dimensional vector stored in the patterns of <span class="math inline">\(\mathcal D\)</span> associated with <span class="math inline">\(x\)</span> (i.e., the row in both the pattern and address matrix is the same), then <span class="math inline">\(\mathcal D(x) \approx y\)</span>. If <span class="math inline">\(x'\)</span> likewise is a degraded form of <span class="math inline">\(x\)</span>, and <span class="math inline">\(y\)</span> the stored pattern for <span class="math inline">\(x\)</span>, then <span class="math inline">\(\mathcal D(x') \approx y\)</span>.</p>
<div id="6d5ff904" class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> CleanupMem:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Simple clean-up memory."""</span></span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim: <span class="bu">int</span>, init_capacity: <span class="bu">int</span> <span class="op">=</span> <span class="dv">20</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The dimensionality of the data</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dim <span class="op">=</span> dim</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The current capacity of the memory</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.capacity <span class="op">=</span> init_capacity</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The number of stored traces</span></span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stored_traces <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>        <span class="co"># The weight matrix</span></span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W <span class="op">=</span> np.zeros(shape<span class="op">=</span>(init_capacity, dim))</span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> write(<span class="va">self</span>, x: np.ndarray) <span class="op">-&gt;</span> np.ndarray:</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Write a value to memory."""</span></span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.stored_traces <span class="op">&gt;=</span> <span class="va">self</span>.capacity:</span>
<span id="cb3-17"><a href="#cb3-17" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.W <span class="op">=</span> np.concatenate([<span class="va">self</span>.W, np.zeros((<span class="va">self</span>.capacity, <span class="va">self</span>.dim))])</span>
<span id="cb3-18"><a href="#cb3-18" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.capacity <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb3-19"><a href="#cb3-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.W[<span class="va">self</span>.stored_traces, :] <span class="op">=</span> x</span>
<span id="cb3-20"><a href="#cb3-20" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stored_traces <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-21"><a href="#cb3-21" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x</span>
<span id="cb3-22"><a href="#cb3-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-23"><a href="#cb3-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read(<span class="va">self</span>, x: np.ndarray) <span class="op">-&gt;</span> <span class="bu">tuple</span>[np.ndarray, np.ndarray]:</span>
<span id="cb3-24"><a href="#cb3-24" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Read a value from memory, returning the value and its recalled form"""</span></span>
<span id="cb3-25"><a href="#cb3-25" aria-hidden="true" tabindex="-1"></a>        similarities <span class="op">=</span> <span class="va">self</span>.W <span class="op">@</span> x</span>
<span id="cb3-26"><a href="#cb3-26" aria-hidden="true" tabindex="-1"></a>        max_sim_idx <span class="op">=</span> np.argmax(np.<span class="bu">abs</span>(similarities))</span>
<span id="cb3-27"><a href="#cb3-27" aria-hidden="true" tabindex="-1"></a>        recalled <span class="op">=</span> <span class="va">self</span>.W[max_sim_idx]</span>
<span id="cb3-28"><a href="#cb3-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x, recalled.view(HRR)</span>
<span id="cb3-29"><a href="#cb3-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-30"><a href="#cb3-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x: np.ndarray) <span class="op">-&gt;</span> <span class="bu">tuple</span>[np.ndarray, np.ndarray]:</span>
<span id="cb3-31"><a href="#cb3-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.read(x)</span>
<span id="cb3-32"><a href="#cb3-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-33"><a href="#cb3-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-34"><a href="#cb3-34" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AssocMem:</span>
<span id="cb3-35"><a href="#cb3-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dim: <span class="bu">int</span>, init_capacity: <span class="bu">int</span> <span class="op">=</span> <span class="dv">20</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-36"><a href="#cb3-36" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.dim <span class="op">=</span> dim</span>
<span id="cb3-37"><a href="#cb3-37" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.capacity <span class="op">=</span> init_capacity</span>
<span id="cb3-38"><a href="#cb3-38" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stored_traces <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-39"><a href="#cb3-39" aria-hidden="true" tabindex="-1"></a>        <span class="co"># addresses</span></span>
<span id="cb3-40"><a href="#cb3-40" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.A <span class="op">=</span> np.zeros((<span class="va">self</span>.capacity, <span class="va">self</span>.dim))</span>
<span id="cb3-41"><a href="#cb3-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># patterns</span></span>
<span id="cb3-42"><a href="#cb3-42" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.P <span class="op">=</span> np.zeros((<span class="va">self</span>.capacity, <span class="va">self</span>.dim))</span>
<span id="cb3-43"><a href="#cb3-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-44"><a href="#cb3-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> write(<span class="va">self</span>, x: np.ndarray, y: np.ndarray) <span class="op">-&gt;</span> <span class="bu">tuple</span>[np.ndarray, np.ndarray]:</span>
<span id="cb3-45"><a href="#cb3-45" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Associate `(x, y)` in memory, returning the values."""</span></span>
<span id="cb3-46"><a href="#cb3-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.stored_traces <span class="op">&gt;=</span> <span class="va">self</span>.capacity:</span>
<span id="cb3-47"><a href="#cb3-47" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.A <span class="op">=</span> np.concatenate([<span class="va">self</span>.A, np.zeros((<span class="va">self</span>.capacity, <span class="va">self</span>.dim))])</span>
<span id="cb3-48"><a href="#cb3-48" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.P <span class="op">=</span> np.concatenate([<span class="va">self</span>.P, np.zeros((<span class="va">self</span>.capacity, <span class="va">self</span>.dim))])</span>
<span id="cb3-49"><a href="#cb3-49" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.capacity <span class="op">*=</span> <span class="dv">2</span></span>
<span id="cb3-50"><a href="#cb3-50" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.A[<span class="va">self</span>.stored_traces, :] <span class="op">=</span> x</span>
<span id="cb3-51"><a href="#cb3-51" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.P[<span class="va">self</span>.stored_traces, :] <span class="op">=</span> y</span>
<span id="cb3-52"><a href="#cb3-52" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.stored_traces <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-53"><a href="#cb3-53" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x, y.view(HRR)</span>
<span id="cb3-54"><a href="#cb3-54" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-55"><a href="#cb3-55" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> read(<span class="va">self</span>, x: np.ndarray) <span class="op">-&gt;</span> <span class="bu">tuple</span>[np.ndarray, np.ndarray]:</span>
<span id="cb3-56"><a href="#cb3-56" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Read `x` from memory, returning the `x` and the resulting value."""</span></span>
<span id="cb3-57"><a href="#cb3-57" aria-hidden="true" tabindex="-1"></a>        similarities <span class="op">=</span> <span class="va">self</span>.A <span class="op">@</span> x</span>
<span id="cb3-58"><a href="#cb3-58" aria-hidden="true" tabindex="-1"></a>        max_sim_idx <span class="op">=</span> np.argmax(np.<span class="bu">abs</span>(similarities))</span>
<span id="cb3-59"><a href="#cb3-59" aria-hidden="true" tabindex="-1"></a>        recalled_pattern <span class="op">=</span> <span class="va">self</span>.P[max_sim_idx]</span>
<span id="cb3-60"><a href="#cb3-60" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> x, recalled_pattern.view(HRR)</span>
<span id="cb3-61"><a href="#cb3-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-62"><a href="#cb3-62" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x: np.ndarray) <span class="op">-&gt;</span> <span class="bu">tuple</span>[np.ndarray, np.ndarray]:</span>
<span id="cb3-63"><a href="#cb3-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.read(x)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s see how these work. For the cleanup memory, we should be able to degrade a value and still be able to retrieve the original form.</p>
<div id="213d1c59" class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">400</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>X <span class="op">=</span> random(<span class="dv">10</span>, dim)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>cleanup_mem <span class="op">=</span> CleanupMem(dim<span class="op">=</span>dim)</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> x <span class="kw">in</span> X:</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    cleanup_mem.write(x)</span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Test regular recall</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> X[<span class="dv">1</span>].squeeze()</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>_, x_hat <span class="op">=</span> cleanup_mem(x)</span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cosine sim between x and x_hat: </span><span class="sc">{</span>x<span class="sc">.</span>cosine_similarity(x_hat)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>x_degraded <span class="op">=</span> X[<span class="dv">1</span>].bind(X[<span class="dv">0</span>]).bind(X[<span class="dv">2</span>]).bind(X[<span class="dv">0</span>].inverse()).bind(X[<span class="dv">2</span>].inverse())</span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>_, x_deg_hat <span class="op">=</span> cleanup_mem(x_degraded)</span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Cosine sim between x and x_deg_hat: </span><span class="sc">{</span>x<span class="sc">.</span>cosine_similarity(x_deg_hat)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Cosine sim between x and x_hat: 1.0
Cosine sim between x and x_deg_hat: 1.0</code></pre>
</div>
</div>
<p>Likewise, we should be able to recall arbitrary associated values even under degradation.</p>
<div id="ce1b7157" class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">400</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> random(<span class="dv">10</span>, dim)</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> random(<span class="dv">10</span>, dim)</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>assoc <span class="op">=</span> AssocMem(dim)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> a, p <span class="kw">in</span> <span class="bu">zip</span>(A, P):</span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    assoc.write(a, p)</span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> A[<span class="dv">1</span>]</span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> P[<span class="dv">1</span>]</span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>_, p_hat <span class="op">=</span> assoc(a)</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Cosine sim between target pattern and recalled pattern: </span><span class="sc">{</span>p<span class="sc">.</span>cosine_similarity(p_hat)<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>a_degraded <span class="op">=</span> A[<span class="dv">1</span>].bind(A[<span class="dv">0</span>]).bind(A[<span class="dv">2</span>]).bind(A[<span class="dv">0</span>].inverse()).bind(A[<span class="dv">2</span>].inverse())</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>_, p_deg_hat <span class="op">=</span> assoc(a_degraded)</span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Cosine similarity between target pattern and recalled pattern from degraded value: </span><span class="sc">{</span>p_deg_hat<span class="sc">.</span>cosine_similarity(p)<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Cosine sim between target pattern and recalled pattern: 1.0000000000000002
Cosine similarity between target pattern and recalled pattern from degraded value: 1.0000000000000002</code></pre>
</div>
</div>
</section>
<section id="applying-memories-to-encoding-and-decoding" class="level2">
<h2 class="anchored" data-anchor-id="applying-memories-to-encoding-and-decoding">Applying memories to encoding and decoding</h2>
<p>Now that we have an associative memory and a cleanup memory, how do we apply it to decoding so that we can preserve information? Recall that role-filler pair encodings for syntactic forms has some degradation of information, especially whenever we have multiple binds and superpositions. Therefore, for each new role-filler pair that we create, what we will do is create a <em>reference</em>. We say that a fresh, random vector <span class="math inline">\(p\)</span> is a reference for some high-dimensional vector <span class="math inline">\(x\)</span> if <span class="math inline">\(p\)</span> is arbitrary and unrelated with <span class="math inline">\(x\)</span>, and we associate <span class="math inline">\(p\)</span> with <span class="math inline">\(x\)</span> in associative memory.</p>
<p>We also can store the contents of role-filler pairs in cleanup memory. This helps further with the preservation of information in role-filler pairs. Figuring out when and when not to use these methods of indirection unfortunately has no real theory behind it. Rather, it is a practical decision made whenever we notice lots of information loss.</p>
<p>Furthermore, instead of using explicit tag roles, what we will do is explicitly superpose the role-filler pair of the contents of the syntax with the tag itself. This let’s us do easier comparison, as well as further limits the possiblity of information loss.</p>
<div id="ee2ca854" class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> encode_with_references(</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>    expr: L,</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    codebook: Codebook,</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    assoc_mem: AssocMem,</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>    cleanup: CleanupMem,</span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> HRR:</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Encode an expression with references and indirection."""</span></span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(expr, Atomic):</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>        name <span class="op">=</span> expr.name</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>        rf <span class="op">=</span> role_filler_pair(</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>            {</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>                <span class="st">"name"</span>: name,</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>            },</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>            codebook<span class="op">=</span>codebook,</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> rf <span class="op">+</span> codebook[<span class="st">"atomic"</span>]</span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, Tuple):</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>        lhs <span class="op">=</span> expr.lhs</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a>        rhs <span class="op">=</span> expr.rhs</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-22"><a href="#cb8-22" aria-hidden="true" tabindex="-1"></a>        enc_lhs <span class="op">=</span> encode_with_references(</span>
<span id="cb8-23"><a href="#cb8-23" aria-hidden="true" tabindex="-1"></a>            lhs, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup</span>
<span id="cb8-24"><a href="#cb8-24" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-25"><a href="#cb8-25" aria-hidden="true" tabindex="-1"></a>        enc_rhs <span class="op">=</span> encode_with_references(</span>
<span id="cb8-26"><a href="#cb8-26" aria-hidden="true" tabindex="-1"></a>            rhs, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup</span>
<span id="cb8-27"><a href="#cb8-27" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-28"><a href="#cb8-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-29"><a href="#cb8-29" aria-hidden="true" tabindex="-1"></a>        cleanup.write(enc_lhs)</span>
<span id="cb8-30"><a href="#cb8-30" aria-hidden="true" tabindex="-1"></a>        cleanup.write(enc_rhs)</span>
<span id="cb8-31"><a href="#cb8-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-32"><a href="#cb8-32" aria-hidden="true" tabindex="-1"></a>        rfpair <span class="op">=</span> (</span>
<span id="cb8-33"><a href="#cb8-33" aria-hidden="true" tabindex="-1"></a>            role_filler_pair(</span>
<span id="cb8-34"><a href="#cb8-34" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"lhs"</span>: enc_lhs, <span class="st">"rhs"</span>: enc_rhs},</span>
<span id="cb8-35"><a href="#cb8-35" aria-hidden="true" tabindex="-1"></a>                codebook<span class="op">=</span>codebook,</span>
<span id="cb8-36"><a href="#cb8-36" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb8-37"><a href="#cb8-37" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> codebook[<span class="st">"tuple"</span>]</span>
<span id="cb8-38"><a href="#cb8-38" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-39"><a href="#cb8-39" aria-hidden="true" tabindex="-1"></a>        ptr <span class="op">=</span> random(<span class="dv">1</span>, codebook.dim).squeeze()</span>
<span id="cb8-40"><a href="#cb8-40" aria-hidden="true" tabindex="-1"></a>        assoc_mem.write(ptr, rfpair)</span>
<span id="cb8-41"><a href="#cb8-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ptr</span>
<span id="cb8-42"><a href="#cb8-42" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(expr, Disjunction):</span>
<span id="cb8-43"><a href="#cb8-43" aria-hidden="true" tabindex="-1"></a>        lhs <span class="op">=</span> expr.lhs</span>
<span id="cb8-44"><a href="#cb8-44" aria-hidden="true" tabindex="-1"></a>        rhs <span class="op">=</span> expr.rhs</span>
<span id="cb8-45"><a href="#cb8-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-46"><a href="#cb8-46" aria-hidden="true" tabindex="-1"></a>        enc_lhs <span class="op">=</span> encode_with_references(</span>
<span id="cb8-47"><a href="#cb8-47" aria-hidden="true" tabindex="-1"></a>            lhs, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup</span>
<span id="cb8-48"><a href="#cb8-48" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-49"><a href="#cb8-49" aria-hidden="true" tabindex="-1"></a>        enc_rhs <span class="op">=</span> encode_with_references(</span>
<span id="cb8-50"><a href="#cb8-50" aria-hidden="true" tabindex="-1"></a>            rhs, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup</span>
<span id="cb8-51"><a href="#cb8-51" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-52"><a href="#cb8-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-53"><a href="#cb8-53" aria-hidden="true" tabindex="-1"></a>        cleanup.write(enc_lhs)</span>
<span id="cb8-54"><a href="#cb8-54" aria-hidden="true" tabindex="-1"></a>        cleanup.write(enc_rhs)</span>
<span id="cb8-55"><a href="#cb8-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-56"><a href="#cb8-56" aria-hidden="true" tabindex="-1"></a>        rfpair <span class="op">=</span> (</span>
<span id="cb8-57"><a href="#cb8-57" aria-hidden="true" tabindex="-1"></a>            role_filler_pair(</span>
<span id="cb8-58"><a href="#cb8-58" aria-hidden="true" tabindex="-1"></a>                {<span class="st">"lhs"</span>: enc_lhs, <span class="st">"rhs"</span>: enc_rhs},</span>
<span id="cb8-59"><a href="#cb8-59" aria-hidden="true" tabindex="-1"></a>                codebook<span class="op">=</span>codebook,</span>
<span id="cb8-60"><a href="#cb8-60" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb8-61"><a href="#cb8-61" aria-hidden="true" tabindex="-1"></a>            <span class="op">+</span> codebook[<span class="st">"disjunction"</span>]</span>
<span id="cb8-62"><a href="#cb8-62" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb8-63"><a href="#cb8-63" aria-hidden="true" tabindex="-1"></a>        ptr <span class="op">=</span> random(<span class="dv">1</span>, codebook.dim).squeeze()</span>
<span id="cb8-64"><a href="#cb8-64" aria-hidden="true" tabindex="-1"></a>        assoc_mem.write(ptr, rfpair)</span>
<span id="cb8-65"><a href="#cb8-65" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> ptr</span>
<span id="cb8-66"><a href="#cb8-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-67"><a href="#cb8-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-68"><a href="#cb8-68" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">1_000</span></span>
<span id="cb8-69"><a href="#cb8-69" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> [<span class="st">"atomic"</span>, <span class="st">"tuple"</span>, <span class="st">"disjunction"</span>]</span>
<span id="cb8-70"><a href="#cb8-70" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> [<span class="st">"tag"</span>, <span class="st">"name"</span>, <span class="st">"lhs"</span>, <span class="st">"rhs"</span>]</span>
<span id="cb8-71"><a href="#cb8-71" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> [<span class="st">"strawberry"</span>, <span class="st">"banana"</span>, <span class="st">"apple"</span>]</span>
<span id="cb8-72"><a href="#cb8-72" aria-hidden="true" tabindex="-1"></a>codebook <span class="op">=</span> Codebook(T <span class="op">+</span> R <span class="op">+</span> A, dim<span class="op">=</span>dim)</span>
<span id="cb8-73"><a href="#cb8-73" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-74"><a href="#cb8-74" aria-hidden="true" tabindex="-1"></a>cleanup_mem <span class="op">=</span> CleanupMem(dim<span class="op">=</span>codebook.dim)</span>
<span id="cb8-75"><a href="#cb8-75" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> item <span class="kw">in</span> codebook.values():</span>
<span id="cb8-76"><a href="#cb8-76" aria-hidden="true" tabindex="-1"></a>    cleanup_mem.write(item)</span>
<span id="cb8-77"><a href="#cb8-77" aria-hidden="true" tabindex="-1"></a>assoc_mem <span class="op">=</span> AssocMem(dim<span class="op">=</span>dim)</span>
<span id="cb8-78"><a href="#cb8-78" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-79"><a href="#cb8-79" aria-hidden="true" tabindex="-1"></a>straw <span class="op">=</span> Atomic(<span class="st">"strawberry"</span>)</span>
<span id="cb8-80"><a href="#cb8-80" aria-hidden="true" tabindex="-1"></a>enc_straw <span class="op">=</span> encode_with_references(</span>
<span id="cb8-81"><a href="#cb8-81" aria-hidden="true" tabindex="-1"></a>    straw, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup_mem</span>
<span id="cb8-82"><a href="#cb8-82" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb8-83"><a href="#cb8-83" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb8-84"><a href="#cb8-84" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Is the encoded `straw` atomic?: </span><span class="sc">{</span>enc_straw<span class="sc">.</span>cosine_similarity(codebook[<span class="st">'atomic'</span>])<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb8-85"><a href="#cb8-85" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Is the encoded `straw` atomic?: 0.7015074268173801</code></pre>
</div>
</div>
<div id="27741147" class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Testing tuples</span></span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>banana <span class="op">=</span> Atomic(<span class="st">"banana"</span>)</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>enc_banana <span class="op">=</span> encode_with_references(</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>    banana, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup_mem</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> Tuple(straw, banana)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a>ptr_t <span class="op">=</span> encode_with_references(</span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>    t, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup_mem</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Is the pointer a tuple?: </span><span class="sc">{</span>ptr_t<span class="sc">.</span>cosine_similarity(codebook[<span class="st">'tuple'</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-14"><a href="#cb10-14" aria-hidden="true" tabindex="-1"></a>_, deref_t <span class="op">=</span> assoc_mem.read(ptr_t)</span>
<span id="cb10-15"><a href="#cb10-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-16"><a href="#cb10-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb10-17"><a href="#cb10-17" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Is the derefenced tuple a tuple?: </span><span class="sc">{</span>deref_t<span class="sc">.</span>cosine_similarity(codebook[<span class="st">'tuple'</span>])<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb10-18"><a href="#cb10-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb10-19"><a href="#cb10-19" aria-hidden="true" tabindex="-1"></a>lhs <span class="op">=</span> deref_t.bind(codebook[<span class="st">"lhs"</span>].inverse())</span>
<span id="cb10-20"><a href="#cb10-20" aria-hidden="true" tabindex="-1"></a>_, lhs <span class="op">=</span> cleanup_mem.read(lhs)</span>
<span id="cb10-21"><a href="#cb10-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Similarity between lhs and atomic: </span><span class="sc">{</span>lhs<span class="sc">.</span>cosine_similarity(codebook[<span class="st">'atomic'</span>])<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb10-22"><a href="#cb10-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb10-23"><a href="#cb10-23" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Is the lhs a strawberry?: </span><span class="sc">{</span>lhs<span class="sc">.</span>bind(codebook[<span class="st">'name'</span>].inverse())<span class="sc">.</span>cosine_similarity(codebook[<span class="st">'strawberry'</span>])<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb10-24"><a href="#cb10-24" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Is the pointer a tuple?: -0.012625734991703514
Is the derefenced tuple a tuple?: 0.5754711851450405
Similarity between lhs and atomic: 0.7015074268173801
Is the lhs a strawberry?: 0.5825174657553933</code></pre>
</div>
</div>
<section id="decoding" class="level4">
<h4 class="anchored" data-anchor-id="decoding">Decoding</h4>
<p>Now that we’ve preserved the information more using indirection, we can also have an easier time in decoding compound representations.</p>
<div id="486f093d" class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> Tuple(straw, banana)</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>t_nest <span class="op">=</span> Tuple(t, t)</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>ptr_t <span class="op">=</span> encode_with_references(</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>    t_nest, codebook<span class="op">=</span>codebook, assoc_mem<span class="op">=</span>assoc_mem, cleanup<span class="op">=</span>cleanup_mem</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>_, deref_t <span class="op">=</span> assoc_mem.read(ptr_t)</span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>_, lhs_ptr <span class="op">=</span> cleanup_mem.read(deref_t.bind(codebook[<span class="st">"lhs"</span>].inverse()))</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>_, deref_lhs <span class="op">=</span> assoc_mem.read(lhs_ptr)</span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>    <span class="ss">f"Is the left-hand side a tuple?: </span><span class="sc">{</span>deref_lhs<span class="sc">.</span>cosine_similarity(codebook[<span class="st">'tuple'</span>])<span class="sc">}</span><span class="ss">"</span></span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Is the left-hand side a tuple?: 0.5754711851450405</code></pre>
</div>
</div>
<p>Implementing decoding the forms with indirection is left as an exercise for the reader. It is always important to remember: you can not be sure that a value that you have is an atomic value that isn’t the result of some kind of indirection. Therefore, one must always be wary of testing for whether the value is atomic. To do so, one can simply test whether some high-dimensional encoded vector is sufficiently similar to the <code>atomic</code> tag. Otherwise, you can treat it as a reference, and dereference it from memory.</p>
<div id="05cc7757" class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> decode_with_references(</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    enc: HRR,</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    codebook: Codebook,</span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a>    assoc_mem: AssocMem,</span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    cleanup_mem: CleanupMem,</span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> L:</span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Decode from our novel encoding with references."""</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>    ...</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
</section>
<section id="alternative-representations-of-syntax" class="level1">
<h1>Alternative Representations of Syntax</h1>
<p>Role-filler pairs are not the only way to represent the abstract syntax of a language. VSAs are able to express really any useful data structure that one could desire: the question then becomes, what is the most useful for the project itself. Aside from role-filler pairs, we can also represent the abstract syntax as <em>trees</em> or <em>sequences</em>. The two main strategies for representing these structures are either some iteration of role-filler pairs.</p>
<section id="trees" class="level2">
<h2 class="anchored" data-anchor-id="trees">Trees</h2>
<p>The abstract syntax of a language can be represented as a <em>tree</em> using a data structure called a <em>sparse coordinate tree</em> <a href="https://arxiv.org/pdf/2412.14076v1">(Soulos, <em>et al.</em>, 2024)</a>. The representation uses two codebooks for <em>content</em>, the <span class="math inline">\(C = [c_1, c_2, \dots, c_N]\)</span> and <em>position</em>: <span class="math inline">\(P = [p_1, p_2, \dots, p_M]\)</span>. Each <span class="math inline">\(p_i\)</span>, <span class="math inline">\(i = 1, \dots, M\)</span> denotes <span class="math inline">\(M\)</span> possible coordinates within the tree. Soulos, <em>et al.</em> have some indexing information in the position vectors <span class="math inline">\(p_i\)</span>, but as long as they are sufficiently distinct they can be anything. Another possible option is to use the set of permutations of some base vector <span class="math inline">\(p_1\)</span>, and the other vectors as: <span class="math display">\[
\begin{align*}
p_2 &amp;= \mathcal{P}^1(p_1), \\
p_3 &amp;= \mathcal{P}^2(p_1), \\
&amp;\vdots \\
p_m &amp;= \mathcal{P}^{(m-1)}(p_1),
\end{align*}
\tag{1}
\]</span> where <span class="math inline">\(\mathcal{P}^n(\cdot)\)</span> denotes the <span class="math inline">\(n\)</span>-th permutation of the vector argument.</p>
<p>Permutations can also be used to “protect” information. Recall that binding creates a new vector which is orthogonal to the operands of the binding. Therefore, if we bind each filler with <span class="math inline">\(n\)</span> permutations of a role, then we create a new and highly uncorrelated vector that is uniquely recoverable by taking the inverse of the bind with the <span class="math inline">\(n\)</span> permutation vectors.</p>
<p>This encoding scheme is intimately related with the tagged unions that tactic that we use above. Instead of using <em>distinct</em> roles for the attributes of the abstract syntax, instead they use an agnostic representation that represents the abstract syntax as tree.</p>
<p>Consider the following tree: <img src="./tree.png" class="img-fluid"></p>
<p>With our tagged union representation, this is: <span class="math display">\[
t_\text{rf} = \texttt{tuple} \oplus (
    (\texttt{lhs} \otimes (\texttt{atomic} \oplus (\texttt{name} \otimes \texttt{strawberry}))) \oplus
    (\texttt{rhs} \otimes (\texttt{atomic} \oplus (\texttt{name} \otimes \texttt{banana})))
)
\tag{2}
\]</span> For our positional encoding, let us assign the positions left-hand side first, so the top of the tree is <span class="math inline">\(p_1\)</span>, going down the left hand branch we have <span class="math inline">\(p_2, p_3, p_4\)</span>, and the right hand side <span class="math inline">\(p_5, p_6, p_7\)</span>. The representation would be: <span class="math display">\[
\begin{align*}
t_\text{pos} &amp;= p_1 \otimes \texttt{tuple} \oplus p_2 \otimes \texttt{atomic} \oplus \\
    &amp;p_3 \otimes \texttt{name} \oplus p_4 \otimes \texttt{strawberry} \\
    &amp;p_5 \otimes \texttt{atomic} \oplus p_6 \otimes \texttt{name} \\
    &amp;p_7 \otimes \texttt{banana}.
\end{align*}
\tag{3}
\]</span> This naive representation will of course be subject to problems of noise. But, there are smarter ways of doing this positional encoding. For example, another tree representation from <a href="https://arxiv.org/pdf/2007.03748">Frady, <em>et al.</em> (2020)</a> is to use permutations of a <em>left</em> and a <em>right</em> base vector.</p>
</section>
<section id="lists" class="level2">
<h2 class="anchored" data-anchor-id="lists">Lists</h2>
<p>Similar to the tree representation, we can use a sort of linked-list structure for encoding the syntax. In this approach, we simply have a codebook of structural roles: <span class="math inline">\(\texttt{left}\)</span>, <span class="math inline">\(\texttt{right}\)</span>, the empty list indicator <span class="math inline">\(\texttt{nil}\)</span>, and a list marker <span class="math inline">\(\varphi\)</span>, accompanied with a codebook of values that we wish to have as elements.</p>
<p>Encoding atomic symbols remains a simple mapping from the symbol to the codebook. However, for non-atomic structures (composite expressions), we can concatenate the elements into a list by using the <span class="math inline">\(\mathsf{cons}\)</span> operation: <span class="math display">\[
\mathsf{cons} (x, y) = (\texttt{left} \otimes x) \oplus (\texttt{right} \otimes y) \oplus \varphi.
\tag{4}
\]</span> A singleton list is represented as <span class="math inline">\(\mathsf{cons}(x, \texttt{nil})\)</span>. This allows us to simply iterate through the list until by retrieving the <span class="math inline">\(\texttt{left}\)</span> item, performing our operation, and then treating the retrieved value from the <span class="math inline">\(\texttt{right}\)</span>.</p>
<p>Like our tagged-union representations these unfortunately are plagued with problems of noise. So, we must unfortunately enter <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> into cleanup memory to enhance recall. Given the ease of this representation, we will be using this for encoding abstract syntax. We’ll see an example below of how this works in practice. Before that, however, we must end our detour and talk about what programs mean: <em>semantics</em>.</p>
</section>
</section>
<section id="its-just-semantics" class="level1">
<h1>It’s just semantics</h1>
<p>Semantics is, broadly, the study of what some language <em>means</em>. In natural language, the semantics investigates how the meaning of words makes a difference in how we can use them and what we do with them. For example, the famous sentence: “Colorless green ideas sleep furiously” is <em>syntactically</em> correct, but there is a different sense to why it seems wrong. There’s something about the words themselves that makes it a bad kind of sentence.</p>
<p>In the same way that we can talk about the meaning of words in natural language, the study of semantics extends to formal languages as well. In fact, semantics for natural language finds it origin in thinkers like Richard Montague (1930-1971), who claimed that there was no intrinsic difference between natural and artificial languages. So, we could use the tools for the latter on the former.</p>
<p>Programming language semantics provide a way for us to describe how we intend the programming language to work. Usually, we proceed with a higher-level description of the general “shape” of how things are supposed to work. The job of compilers and interpretation is to implement these semantic rules as faithfully as possible. The reason that we provide a high-level and abstract definition of the semantics of programming languages is because we want to leave room for the writers of compilers and interpreters to perform optimizations. If our language standard, that is the document which formally describes the language in total, requires that the language have a very specific and <em>inefficient</em> implementation, implementers would have to break with the standard to make something fast and useful. But this would just be a violation of what it means to be a language standard (something that all implementations ought to follow).</p>
<section id="designing-a-denotation" class="level2">
<h2 class="anchored" data-anchor-id="designing-a-denotation">Designing a denotation</h2>
<p>Given a language <span class="math inline">\(\mathcal{L}\)</span>, typically described by a list of syntactic roles, designing the semantics of the language requires us to define a function that, on the basis of the syntax of the language, assigns some meaning or <em>denotation</em> to the syntax.</p>
<p>To put it in simpler terms, we need to provide a function that maps from the syntax of <span class="math inline">\(\mathcal{L}\)</span> to some other domain that captures the essential properties of <span class="math inline">\(\mathcal{L}\)</span>. We call this function the <em>denotation</em> function, denoted by <span class="math inline">\(\| \cdot \|\)</span>.</p>
<section id="a-denotation-for-mathcall_textfruit" class="level3">
<h3 class="anchored" data-anchor-id="a-denotation-for-mathcall_textfruit">A denotation for <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span></h3>
<p>To provide an intuition here, suppose that <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span> is a programming language, and we want to design a semantics for this programming language. Of course, this language wouldn’t be very useful, except for describing collections of strawberries, bananas, and apples. But, it is good practice to begin to grasp what it takes to make a denotation.</p>
<p>To begin, we have to proceed recursively over the inductive definition of <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span>. By defining the denotation in terms of atomic elements as a base case, and then composite elements, we are following something known as the <em>principle of compositionality</em>: namely, that the meaning of an expression in the language <span class="math inline">\(\mathcal{L}_\text{let}\)</span> is determined the meaning of the parts of the expression.</p>
<p>Let <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span> be a set called the <em>model</em> of <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span>. The denotation function <span class="math inline">\(\| \cdot \|\)</span> maps from elements in <span class="math inline">\(\mathcal L_\text{fruit}\)</span> to elements in <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span>. To begin, we need to populate <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span>. First, we need to have elements that correspond with the atomic elements of <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span>. Let <span class="math inline">\(\mathsf{strawberry}\)</span>, <span class="math inline">\(\mathsf{apple}\)</span>, and <span class="math inline">\(\mathsf{banana}\)</span> be three elements in <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span>. We can distinguish between elements in <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span> and atomic elements in <span class="math inline">\(\mathcal{L}_\text{fruit}\)</span> by the lack of serifs. The denotation of atomic elements is thus: <span class="math display">\[
\begin{align*}
\| \texttt{apple} \| &amp;= \mathsf{apple}, \\
\| \texttt{banana} \| &amp;= \mathsf{banana}, \\
\| \texttt{strawberry} \| &amp;= \mathsf{strawberry}.
\end{align*}
\tag{5}
\]</span></p>
<p>Next, we have to populate the composite expressions. For tuples, we will say that (1) the denotation of the left-hand side is in <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span>, (2) the denotation of the right-hand side is in <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span>, and (3) that the set of <span class="math inline">\(\{\|\text{lhs}\|, \{\|\text{lhs}\|,~\|\text{rhs}\|\}\}\)</span> is in <span class="math inline">\(\mathcal{M}_\text{fruit}\)</span> (the set encoding of a tuple): <span class="math display">\[
\begin{align*}
\| (x, y) \| = \{ \| x \|, \{ \| x \|, \|y\|\}\}.
\end{align*}
\tag{6}
\]</span></p>
</section>
</section>
<section id="real-world-example" class="level2">
<h2 class="anchored" data-anchor-id="real-world-example">Real-world example</h2>
<p>A real-world example of how actual language specifications define the operational semantics of a language is the <a href="https://conservatory.scheme.org/schemers/Documents/Standards/R5RS/r5rs.pdf">R5RS Standard for Scheme</a>.</p>
</section>
</section>
<section id="the-let-programming-language" class="level1">
<h1>The LET Programming Language</h1>
<p>Now that we have an understanding of representing the syntax of programming languages, as well as the semantics, let’s work out a toy example.</p>
<p>The LET Programming language <a href="https://www.eopl3.com">(Friedman &amp; Wand, 2008; Ch. 3)</a> is a toy language that contains: simple expressions like addition and subtraction, testing whether or not an item is <span class="math inline">\(0\)</span>, function application, conditional evaluation, and variable binding using <code>let</code> expressions.</p>
<p>Let <span class="math inline">\(\mathcal{L}_{\text{let}}\)</span> be the language defined by the following BNF specification:</p>
<pre class="bnf"><code>&lt;program&gt; ::= &lt;expression&gt;

&lt;expression&gt; ::= &lt;number&gt;   
              |  -(&lt;expression&gt;, &lt;expression&gt;)
              | zero? (&lt;expression&gt;)
              | if &lt;expression&gt; then &lt;expression&gt; else &lt;expression&gt;
              | &lt;identifier&gt;
              | let &lt;expression&gt; = &lt;expression&gt; in &lt;expression&gt;</code></pre>
<div id="66911dfc" class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Expression(metaclass<span class="op">=</span>ABCMeta):</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Abstract base class of Let expressions."""</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">pass</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Number(Expression):</span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Number expressions."""</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    num: <span class="bu">int</span></span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Identifier(Expression):</span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Identifier expressions."""</span></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    var: <span class="bu">str</span></span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> IsZero(Expression):</span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""zero?"""</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    exp1: Expression</span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> If(Expression):</span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""If expressions."""</span></span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    exp1: Expression</span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    exp2: Expression</span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>    exp3: Expression</span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Let(Expression):</span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""let expressions."""</span></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    var: <span class="bu">str</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    exp1: Expression</span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a>    body: Expression</span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a><span class="at">@dataclass</span></span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Diff(Expression):</span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Difference expressions"""</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a>    exp1: Expression</span>
<span id="cb16-52"><a href="#cb16-52" aria-hidden="true" tabindex="-1"></a>    exp2: Expression</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Next, we define our encoding function. We’re going to use the list encoding that we talked about earlier. Numbers and identifiers will be atomic expressions. For numbers, we’re going to cheat a little bit by keeping an varying size array of “scalar vectors” around, called it <span class="math inline">\(\mathcal{I} = [i_0, i_1, \dots]\)</span>. The encoding for some number <span class="math inline">\(n\)</span> will just be <span class="math inline">\(i_n\)</span>. We will then superpose this representation with a tag <span class="math inline">\(\texttt{num}\)</span>.</p>
<p>For composite expressions, we will use a list encoding. The first element of the list will be a tag denoting what kind of expression it is. These can be either <span class="math inline">\(-\)</span>, <span class="math inline">\(\texttt{let}\)</span>, <span class="math inline">\(\texttt{if}\)</span>, or <span class="math inline">\(\texttt{zero?}\)</span>.</p>
<div id="d86402eb" class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Setting up the environment</span></span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>dim <span class="op">=</span> <span class="dv">1_000</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> [<span class="st">"-"</span>, <span class="st">"let"</span>, <span class="st">"if"</span>, <span class="st">"zero?"</span>, <span class="st">"num"</span>]</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>K <span class="op">=</span> [<span class="st">"φ"</span>, <span class="st">"lhs"</span>, <span class="st">"rhs"</span>, <span class="st">"nil"</span>]</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> random(<span class="dv">100</span>, dim)  <span class="co"># the dynamic array containing our number vectors</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>codebook <span class="op">=</span> Codebook(T <span class="op">+</span> K, dim<span class="op">=</span>dim)  <span class="co"># we'll update the codebook with new,</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co"># user-defined symbols as we encounter them</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a>assoc_mem <span class="op">=</span> AssocMem(dim<span class="op">=</span>codebook.dim)</span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a>cleanup_mem <span class="op">=</span> CleanupMem(dim<span class="op">=</span>codebook.dim)</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> val <span class="kw">in</span> codebook.values():</span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a>    cleanup_mem.write(val)</span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> make_cons(</span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a>    lhs: HRR,</span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a>    rhs: HRR,</span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a>    codebook: Codebook,</span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    assoc_mem: AssocMem,</span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a>    cleanup_mem: CleanupMem,</span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> HRR:</span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Helper function for making pointers."""</span></span>
<span id="cb17-25"><a href="#cb17-25" aria-hidden="true" tabindex="-1"></a>    lhs <span class="op">=</span> cleanup_mem.write(lhs)</span>
<span id="cb17-26"><a href="#cb17-26" aria-hidden="true" tabindex="-1"></a>    rhs <span class="op">=</span> cleanup_mem.write(rhs)</span>
<span id="cb17-27"><a href="#cb17-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-28"><a href="#cb17-28" aria-hidden="true" tabindex="-1"></a>    tup <span class="op">=</span> (lhs.bind(codebook[<span class="st">"lhs"</span>])) <span class="op">+</span> (rhs.bind(codebook[<span class="st">"rhs"</span>])) <span class="op">+</span> codebook[<span class="st">"φ"</span>]</span>
<span id="cb17-29"><a href="#cb17-29" aria-hidden="true" tabindex="-1"></a>    tup <span class="op">=</span> tup <span class="op">/</span> np.linalg.vector_norm(tup)</span>
<span id="cb17-30"><a href="#cb17-30" aria-hidden="true" tabindex="-1"></a>    ptr <span class="op">=</span> random(<span class="dv">1</span>, codebook.dim).squeeze()</span>
<span id="cb17-31"><a href="#cb17-31" aria-hidden="true" tabindex="-1"></a>    assoc_mem.write(ptr, tup)</span>
<span id="cb17-32"><a href="#cb17-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> ptr</span>
<span id="cb17-33"><a href="#cb17-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-34"><a href="#cb17-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-35"><a href="#cb17-35" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cons(</span>
<span id="cb17-36"><a href="#cb17-36" aria-hidden="true" tabindex="-1"></a>    xs: <span class="bu">list</span>[HRR], codebook: Codebook, assoc_mem: AssocMem, cleanup_mem: CleanupMem</span>
<span id="cb17-37"><a href="#cb17-37" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> HRR:</span>
<span id="cb17-38"><a href="#cb17-38" aria-hidden="true" tabindex="-1"></a>    base <span class="op">=</span> codebook[<span class="st">"nil"</span>]</span>
<span id="cb17-39"><a href="#cb17-39" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> x <span class="kw">in</span> <span class="bu">reversed</span>(xs):</span>
<span id="cb17-40"><a href="#cb17-40" aria-hidden="true" tabindex="-1"></a>        base <span class="op">=</span> make_cons(x, base, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-41"><a href="#cb17-41" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> base</span>
<span id="cb17-42"><a href="#cb17-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-43"><a href="#cb17-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-44"><a href="#cb17-44" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> encode_let(</span>
<span id="cb17-45"><a href="#cb17-45" aria-hidden="true" tabindex="-1"></a>    e: Expression, codebook: Codebook, assoc_mem: AssocMem, cleanup_mem: CleanupMem</span>
<span id="cb17-46"><a href="#cb17-46" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> HRR:</span>
<span id="cb17-47"><a href="#cb17-47" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Encode our LET Language using our list encoding."""</span></span>
<span id="cb17-48"><a href="#cb17-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">global</span> I</span>
<span id="cb17-49"><a href="#cb17-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-50"><a href="#cb17-50" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">isinstance</span>(e, Identifier):</span>
<span id="cb17-51"><a href="#cb17-51" aria-hidden="true" tabindex="-1"></a>        val <span class="op">=</span> e.var</span>
<span id="cb17-52"><a href="#cb17-52" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> val <span class="kw">not</span> <span class="kw">in</span> codebook:</span>
<span id="cb17-53"><a href="#cb17-53" aria-hidden="true" tabindex="-1"></a>            codebook[val] <span class="op">=</span> random(<span class="dv">1</span>, codebook.dim).squeeze()</span>
<span id="cb17-54"><a href="#cb17-54" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> codebook[val]</span>
<span id="cb17-55"><a href="#cb17-55" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(e, Number):</span>
<span id="cb17-56"><a href="#cb17-56" aria-hidden="true" tabindex="-1"></a>        num <span class="op">=</span> e.num</span>
<span id="cb17-57"><a href="#cb17-57" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> num <span class="op">&gt;=</span> I.shape[<span class="dv">0</span>]:</span>
<span id="cb17-58"><a href="#cb17-58" aria-hidden="true" tabindex="-1"></a>            I <span class="op">=</span> np.concatenate([I, np.random(<span class="dv">100</span>, dim)])</span>
<span id="cb17-59"><a href="#cb17-59" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> I[num] <span class="op">+</span> codebook[<span class="st">"num"</span>]</span>
<span id="cb17-60"><a href="#cb17-60" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(e, IsZero):</span>
<span id="cb17-61"><a href="#cb17-61" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> e.exp1</span>
<span id="cb17-62"><a href="#cb17-62" aria-hidden="true" tabindex="-1"></a>        enc_exp1 <span class="op">=</span> encode_let(exp1, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-63"><a href="#cb17-63" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cons([codebook[<span class="st">"zero?"</span>], enc_exp1], codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-64"><a href="#cb17-64" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(e, If):</span>
<span id="cb17-65"><a href="#cb17-65" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> e.exp1</span>
<span id="cb17-66"><a href="#cb17-66" aria-hidden="true" tabindex="-1"></a>        exp2 <span class="op">=</span> e.exp2</span>
<span id="cb17-67"><a href="#cb17-67" aria-hidden="true" tabindex="-1"></a>        exp3 <span class="op">=</span> e.exp3</span>
<span id="cb17-68"><a href="#cb17-68" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-69"><a href="#cb17-69" aria-hidden="true" tabindex="-1"></a>        enc_exp1 <span class="op">=</span> encode_let(exp1, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-70"><a href="#cb17-70" aria-hidden="true" tabindex="-1"></a>        enc_exp2 <span class="op">=</span> encode_let(exp2, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-71"><a href="#cb17-71" aria-hidden="true" tabindex="-1"></a>        enc_exp3 <span class="op">=</span> encode_let(exp3, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-72"><a href="#cb17-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-73"><a href="#cb17-73" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cons(</span>
<span id="cb17-74"><a href="#cb17-74" aria-hidden="true" tabindex="-1"></a>            [</span>
<span id="cb17-75"><a href="#cb17-75" aria-hidden="true" tabindex="-1"></a>                codebook[<span class="st">"if"</span>],</span>
<span id="cb17-76"><a href="#cb17-76" aria-hidden="true" tabindex="-1"></a>                enc_exp1,</span>
<span id="cb17-77"><a href="#cb17-77" aria-hidden="true" tabindex="-1"></a>                enc_exp2,</span>
<span id="cb17-78"><a href="#cb17-78" aria-hidden="true" tabindex="-1"></a>                enc_exp3,</span>
<span id="cb17-79"><a href="#cb17-79" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb17-80"><a href="#cb17-80" aria-hidden="true" tabindex="-1"></a>            codebook,</span>
<span id="cb17-81"><a href="#cb17-81" aria-hidden="true" tabindex="-1"></a>            assoc_mem,</span>
<span id="cb17-82"><a href="#cb17-82" aria-hidden="true" tabindex="-1"></a>            cleanup_mem,</span>
<span id="cb17-83"><a href="#cb17-83" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb17-84"><a href="#cb17-84" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(e, Let):</span>
<span id="cb17-85"><a href="#cb17-85" aria-hidden="true" tabindex="-1"></a>        var <span class="op">=</span> e.var</span>
<span id="cb17-86"><a href="#cb17-86" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> e.exp1</span>
<span id="cb17-87"><a href="#cb17-87" aria-hidden="true" tabindex="-1"></a>        body <span class="op">=</span> e.body</span>
<span id="cb17-88"><a href="#cb17-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-89"><a href="#cb17-89" aria-hidden="true" tabindex="-1"></a>        enc_var <span class="op">=</span> <span class="va">None</span></span>
<span id="cb17-90"><a href="#cb17-90" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> var <span class="kw">in</span> codebook:</span>
<span id="cb17-91"><a href="#cb17-91" aria-hidden="true" tabindex="-1"></a>            enc_var <span class="op">=</span> codebook[var]</span>
<span id="cb17-92"><a href="#cb17-92" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb17-93"><a href="#cb17-93" aria-hidden="true" tabindex="-1"></a>            codebook[var] <span class="op">=</span> random(<span class="dv">1</span>, codebook.dim).squeeze()</span>
<span id="cb17-94"><a href="#cb17-94" aria-hidden="true" tabindex="-1"></a>            enc_var <span class="op">=</span> codebook[var]</span>
<span id="cb17-95"><a href="#cb17-95" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-96"><a href="#cb17-96" aria-hidden="true" tabindex="-1"></a>        enc_exp1 <span class="op">=</span> encode_let(exp1, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-97"><a href="#cb17-97" aria-hidden="true" tabindex="-1"></a>        enc_body <span class="op">=</span> encode_let(body, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-98"><a href="#cb17-98" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-99"><a href="#cb17-99" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cons(</span>
<span id="cb17-100"><a href="#cb17-100" aria-hidden="true" tabindex="-1"></a>            [</span>
<span id="cb17-101"><a href="#cb17-101" aria-hidden="true" tabindex="-1"></a>                codebook[<span class="st">"let"</span>],</span>
<span id="cb17-102"><a href="#cb17-102" aria-hidden="true" tabindex="-1"></a>                enc_var,</span>
<span id="cb17-103"><a href="#cb17-103" aria-hidden="true" tabindex="-1"></a>                enc_exp1,</span>
<span id="cb17-104"><a href="#cb17-104" aria-hidden="true" tabindex="-1"></a>                enc_body,</span>
<span id="cb17-105"><a href="#cb17-105" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb17-106"><a href="#cb17-106" aria-hidden="true" tabindex="-1"></a>            codebook,</span>
<span id="cb17-107"><a href="#cb17-107" aria-hidden="true" tabindex="-1"></a>            assoc_mem,</span>
<span id="cb17-108"><a href="#cb17-108" aria-hidden="true" tabindex="-1"></a>            cleanup_mem,</span>
<span id="cb17-109"><a href="#cb17-109" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb17-110"><a href="#cb17-110" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> <span class="bu">isinstance</span>(e, Diff):</span>
<span id="cb17-111"><a href="#cb17-111" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> e.exp1</span>
<span id="cb17-112"><a href="#cb17-112" aria-hidden="true" tabindex="-1"></a>        exp2 <span class="op">=</span> e.exp2</span>
<span id="cb17-113"><a href="#cb17-113" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-114"><a href="#cb17-114" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> encode_let(exp1, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-115"><a href="#cb17-115" aria-hidden="true" tabindex="-1"></a>        exp2 <span class="op">=</span> encode_let(exp2, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb17-116"><a href="#cb17-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-117"><a href="#cb17-117" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cons(</span>
<span id="cb17-118"><a href="#cb17-118" aria-hidden="true" tabindex="-1"></a>            [</span>
<span id="cb17-119"><a href="#cb17-119" aria-hidden="true" tabindex="-1"></a>                codebook[<span class="st">"-"</span>],</span>
<span id="cb17-120"><a href="#cb17-120" aria-hidden="true" tabindex="-1"></a>                exp1,</span>
<span id="cb17-121"><a href="#cb17-121" aria-hidden="true" tabindex="-1"></a>                exp2,</span>
<span id="cb17-122"><a href="#cb17-122" aria-hidden="true" tabindex="-1"></a>            ],</span>
<span id="cb17-123"><a href="#cb17-123" aria-hidden="true" tabindex="-1"></a>            codebook,</span>
<span id="cb17-124"><a href="#cb17-124" aria-hidden="true" tabindex="-1"></a>            assoc_mem,</span>
<span id="cb17-125"><a href="#cb17-125" aria-hidden="true" tabindex="-1"></a>            cleanup_mem,</span>
<span id="cb17-126"><a href="#cb17-126" aria-hidden="true" tabindex="-1"></a>        )</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>To verify the correctness of our encoding, we will also define a decoding function to return the expressions to a human-readable format.</p>
<div id="281450e8" class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_atomic(</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    x: HRR, codebook: Codebook, assoc_mem: AssocMem, theta: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Test if a value is atomic"</span></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Test to see if the value is a pointer; i.e., if the value is in</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># the address space of the associative memory</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    addrs <span class="op">=</span> assoc_mem.A</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a>    dot <span class="op">=</span> addrs <span class="op">@</span> x</span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a>    max_cosine_sim <span class="op">=</span> np.argmax(dot)</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> dot[max_cosine_sim] <span class="op">&lt;</span> theta</span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_int(x: HRR, codebook: Codebook, theta: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span>) <span class="op">-&gt;</span> <span class="bu">bool</span>:</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">"Test if a value is a number"</span></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x.cosine_similarity(codebook[<span class="st">"num"</span>]) <span class="op">&gt;</span> theta</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> car(</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>    x: HRR, codebook: Codebook, assoc_mem: AssocMem, cleanup_mem: CleanupMem, is_ptr: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> HRR:</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Retrieve the head of a list."""</span></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> is_ptr:</span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>        _, x <span class="op">=</span> cleanup_mem.read(x)</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a>        _, x <span class="op">=</span> assoc_mem.read(x)</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a>    head <span class="op">=</span> x.bind(codebook[<span class="st">"lhs"</span>].inverse())</span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a>    _, head <span class="op">=</span> cleanup_mem.read(head)</span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> head</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cdr(</span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>    x: HRR, codebook: Codebook, assoc_mem: AssocMem, cleanup_mem: CleanupMem, is_ptr: <span class="bu">bool</span> <span class="op">=</span> <span class="va">False</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> HRR:</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Retrieve the tail of a list."""</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> is_ptr:</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a>        _, x <span class="op">=</span> cleanup_mem.read(x)</span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>        _, x <span class="op">=</span> assoc_mem.read(x)</span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>    tail <span class="op">=</span> x.bind(codebook[<span class="st">"rhs"</span>].inverse())</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>    _, tail <span class="op">=</span> cleanup_mem.read(tail)</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> tail</span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_nil(x: HRR, codebook: Codebook, theta: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span>) <span class="op">-&gt;</span> HRR:</span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Test if a value is `== codebook['nil']`."""</span></span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> x.cosine_similarity(codebook[<span class="st">"nil"</span>]) <span class="op">&gt;</span> theta</span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> decode_let(</span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a>    enc: HRR,</span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>    codebook: Codebook,</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a>    assoc_mem: AssocMem,</span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>    cleanup_mem: CleanupMem,</span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>    theta: <span class="bu">float</span> <span class="op">=</span> <span class="fl">0.2</span>,</span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a>) <span class="op">-&gt;</span> Expression:</span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Decode a let expression from HRR back to Python object."""</span></span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> is_atomic(enc, codebook, assoc_mem):</span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> is_int(enc, codebook):</span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a>            sims <span class="op">=</span> I <span class="op">@</span> enc</span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a>            max_sim_idx <span class="op">=</span> np.argmax(sims)</span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Number(max_sim_idx)</span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>            keys, values <span class="op">=</span> <span class="bu">zip</span>(<span class="op">*</span>codebook.items())</span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>            values <span class="op">=</span> np.array(values)</span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a>            sims <span class="op">=</span> values <span class="op">@</span> enc</span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a>            max_sim_idx <span class="op">=</span> np.argmax(sims)</span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a>            name <span class="op">=</span> keys[max_sim_idx]</span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span> Identifier(name)</span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The value is non-atomic, meaning that it needs to be de-referenced.</span></span>
<span id="cb18-71"><a href="#cb18-71" aria-hidden="true" tabindex="-1"></a>    _, deref <span class="op">=</span> assoc_mem.read(enc)</span>
<span id="cb18-72"><a href="#cb18-72" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-73"><a href="#cb18-73" aria-hidden="true" tabindex="-1"></a>    head <span class="op">=</span> car(deref, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb18-74"><a href="#cb18-74" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> head.cosine_similarity(codebook[<span class="st">"zero?"</span>]) <span class="op">&gt;</span> theta:</span>
<span id="cb18-75"><a href="#cb18-75" aria-hidden="true" tabindex="-1"></a>        cdr_ <span class="op">=</span> cdr(deref, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb18-76"><a href="#cb18-76" aria-hidden="true" tabindex="-1"></a>        enc_exp1 <span class="op">=</span> car(cdr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-77"><a href="#cb18-77" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> decode_let(enc_exp1, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb18-78"><a href="#cb18-78" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> IsZero(exp1)</span>
<span id="cb18-79"><a href="#cb18-79" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> head.cosine_similarity(codebook[<span class="st">"if"</span>]) <span class="op">&gt;</span> theta:</span>
<span id="cb18-80"><a href="#cb18-80" aria-hidden="true" tabindex="-1"></a>        cdr_ <span class="op">=</span> cdr(deref, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb18-81"><a href="#cb18-81" aria-hidden="true" tabindex="-1"></a>        enc_exp1 <span class="op">=</span> car(cdr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-82"><a href="#cb18-82" aria-hidden="true" tabindex="-1"></a>        cddr_ <span class="op">=</span> cdr(cdr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-83"><a href="#cb18-83" aria-hidden="true" tabindex="-1"></a>        enc_exp2 <span class="op">=</span> car(cddr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-84"><a href="#cb18-84" aria-hidden="true" tabindex="-1"></a>        cdddr_ <span class="op">=</span> cdr(cddr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-85"><a href="#cb18-85" aria-hidden="true" tabindex="-1"></a>        enc_exp3 <span class="op">=</span> car(cdddr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-86"><a href="#cb18-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-87"><a href="#cb18-87" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> decode_let(enc_exp1, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-88"><a href="#cb18-88" aria-hidden="true" tabindex="-1"></a>        exp2 <span class="op">=</span> decode_let(enc_exp2, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-89"><a href="#cb18-89" aria-hidden="true" tabindex="-1"></a>        exp3 <span class="op">=</span> decode_let(enc_exp3, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-90"><a href="#cb18-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-91"><a href="#cb18-91" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> If(exp1, exp2, exp3)</span>
<span id="cb18-92"><a href="#cb18-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> head.cosine_similarity(codebook[<span class="st">"let"</span>]) <span class="op">&gt;</span> theta:</span>
<span id="cb18-93"><a href="#cb18-93" aria-hidden="true" tabindex="-1"></a>        cdr_ <span class="op">=</span> cdr(deref, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb18-94"><a href="#cb18-94" aria-hidden="true" tabindex="-1"></a>        enc_exp1 <span class="op">=</span> car(cdr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-95"><a href="#cb18-95" aria-hidden="true" tabindex="-1"></a>        cddr_ <span class="op">=</span> cdr(cdr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-96"><a href="#cb18-96" aria-hidden="true" tabindex="-1"></a>        enc_exp2 <span class="op">=</span> car(cddr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-97"><a href="#cb18-97" aria-hidden="true" tabindex="-1"></a>        cdddr_ <span class="op">=</span> cdr(cddr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-98"><a href="#cb18-98" aria-hidden="true" tabindex="-1"></a>        enc_exp3 <span class="op">=</span> car(cdddr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-99"><a href="#cb18-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-100"><a href="#cb18-100" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> decode_let(enc_exp1, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-101"><a href="#cb18-101" aria-hidden="true" tabindex="-1"></a>        exp2 <span class="op">=</span> decode_let(enc_exp2, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-102"><a href="#cb18-102" aria-hidden="true" tabindex="-1"></a>        exp3 <span class="op">=</span> decode_let(enc_exp3, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-103"><a href="#cb18-103" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-104"><a href="#cb18-104" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Let(exp1, exp2, exp3)</span>
<span id="cb18-105"><a href="#cb18-105" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> head.cosine_similarity(codebook[<span class="st">"-"</span>]) <span class="op">&gt;</span> theta:</span>
<span id="cb18-106"><a href="#cb18-106" aria-hidden="true" tabindex="-1"></a>        cdr_ <span class="op">=</span> cdr(deref, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb18-107"><a href="#cb18-107" aria-hidden="true" tabindex="-1"></a>        enc_exp1 <span class="op">=</span> car(cdr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-108"><a href="#cb18-108" aria-hidden="true" tabindex="-1"></a>        cddr_ <span class="op">=</span> cdr(cdr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-109"><a href="#cb18-109" aria-hidden="true" tabindex="-1"></a>        enc_exp2 <span class="op">=</span> car(cddr_, codebook, assoc_mem, cleanup_mem, is_ptr<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb18-110"><a href="#cb18-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-111"><a href="#cb18-111" aria-hidden="true" tabindex="-1"></a>        exp1 <span class="op">=</span> decode_let(enc_exp1, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-112"><a href="#cb18-112" aria-hidden="true" tabindex="-1"></a>        exp2 <span class="op">=</span> decode_let(enc_exp2, codebook, assoc_mem, cleanup_mem, theta<span class="op">=</span>theta)</span>
<span id="cb18-113"><a href="#cb18-113" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> Diff(exp1, exp2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="bea9821e" class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> Identifier(<span class="st">"foo"</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>enc_x <span class="op">=</span> encode_let(x, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode_let(enc_x, codebook, assoc_mem, cleanup_mem))</span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> Number(<span class="dv">3</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a>enc_n <span class="op">=</span> encode_let(n, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode_let(enc_n, codebook, assoc_mem, cleanup_mem))</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a>z <span class="op">=</span> IsZero(x)</span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>enc_z <span class="op">=</span> encode_let(z, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode_let(enc_z, codebook, assoc_mem, cleanup_mem))</span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> Diff(n, n)</span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original expression: </span><span class="sc">{</span>d<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>enc_d <span class="op">=</span> encode_let(d, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode_let(enc_d, codebook, assoc_mem, cleanup_mem))</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> If(n, z, d)</span>
<span id="cb19-19"><a href="#cb19-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original expression: </span><span class="sc">{</span>d<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-20"><a href="#cb19-20" aria-hidden="true" tabindex="-1"></a>enc_i <span class="op">=</span> encode_let(i, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb19-21"><a href="#cb19-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode_let(enc_i, codebook, assoc_mem, cleanup_mem))</span>
<span id="cb19-22"><a href="#cb19-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-23"><a href="#cb19-23" aria-hidden="true" tabindex="-1"></a>let <span class="op">=</span> Let(<span class="st">"bar"</span>, z, d)</span>
<span id="cb19-24"><a href="#cb19-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Original expression: </span><span class="sc">{</span>let<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb19-25"><a href="#cb19-25" aria-hidden="true" tabindex="-1"></a>enc_l <span class="op">=</span> encode_let(let, codebook, assoc_mem, cleanup_mem)</span>
<span id="cb19-26"><a href="#cb19-26" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(decode_let(enc_l, codebook, assoc_mem, cleanup_mem))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Identifier(var='foo')
Number(num=np.int64(3))
IsZero(exp1=Identifier(var='foo'))
Original expression: Diff(exp1=Number(num=3), exp2=Number(num=3))
Diff(exp1=Number(num=np.int64(3)), exp2=Number(num=np.int64(3)))
Original expression: Diff(exp1=Number(num=3), exp2=Number(num=3))
If(exp1=Number(num=np.int64(3)), exp2=IsZero(exp1=Identifier(var='foo')), exp3=Diff(exp1=Number(num=np.int64(3)), exp2=Number(num=np.int64(3))))
Original expression: Let(var='bar', exp1=IsZero(exp1=Identifier(var='foo')), body=Diff(exp1=Number(num=3), exp2=Number(num=3)))
Let(var=Identifier(var='bar'), exp1=IsZero(exp1=Identifier(var='foo')), body=Diff(exp1=Number(num=np.int64(3)), exp2=Number(num=np.int64(3))))</code></pre>
</div>
</div>
<section id="the-semantics-for-mathcall_textlet" class="level2">
<h2 class="anchored" data-anchor-id="the-semantics-for-mathcall_textlet">The Semantics for <span class="math inline">\(\mathcal{L}_\text{let}\)</span></h2>
<p>The semantics of <span class="math inline">\(\mathcal{L}_\text{let}\)</span> require us to provide some function and set definitions. We will list them below, and then we will informally discuss what they are and what they do:</p>
<p><span class="math display">\[
\begin{align}
\text{Var} &amp;= \{x_1, x_2, \dots\} \tag{7}  \\
\mathcal{n} &amp;= \{n_1, n_2, \dots \} \tag{8} \\
\mathcal{A} &amp;: \mathbb{R}^D \to \mathbb{R}^D \tag{9} \\
\mathcal{C} &amp;: \mathbb{R}^D \to \mathbb{R}^D \tag{10} \\
\mathcal{X} &amp;: \text{Var} \to \mathbb{R}^D \tag{11} \\
\mathcal{I} &amp;: \mathbb{N} \to \mathbb{R}^D \tag{12} \\
\mathsf{checkInt} &amp;: \mathbb{R}^D \to \{0, 1\}  \tag{13} \\
\mathsf{expandToN} &amp;: (\mathcal{I} \times \mathbb{N}) \to \mathcal{I} \tag {14}\\
\mathsf{diff} &amp;: (\mathbb{R}^D \times \mathbb{R}^D \times \mathcal{I}) \to \mathbb{R}^D \tag{15} \\
(\cdot \gets \cdot) &amp;: (\mathcal{C} \times \mathbb{R}^D) \to \mathbb{0} \tag{16} \\
(\cdot \gets (\cdot, \cdot)) &amp;: (\mathcal{A} \times \mathbb{R}^D \times \mathbb{R}^D) \to \mathbb{0} \tag{17} \\
\mathsf{updateCodebook} &amp;: (\mathcal{X} \times \text{Var}) \to \mathbb{0} \tag{18} \\
\end{align}
\]</span></p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/hanleyc01\.github\.io\/vsa-compilation");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




<footer class="footer"><div class="nav-footer"><div class="nav-footer-center"><div class="toc-actions d-sm-block d-md-none"><ul><li><a href="https://github.com/hanleyc01/vsa-compilation/issues/new" class="toc-action"><i class="bi bi-github"></i>Report an issue</a></li></ul></div></div></div></footer></body></html>